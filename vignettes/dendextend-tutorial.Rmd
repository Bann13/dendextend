<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Doing more with dendrogram objects using dendextend}
-->


```{r header, echo=FALSE}
# For this vignette, I use the `markdown.HTML.header` option to modify a few CSS rules in the default CSS style:
options(markdown.HTML.header = system.file('misc', 'vignette.css', package='knitr'))
```


# Doing more with dendrogram objects
# A tutorial on using the {**_dendextend_**} package
================================================


Introduction
---------------


### The "dendrogram" object

The *"dendrogram"* class provides general functions for handling tree-like structures in R. It is intended as a replacement for similar functions in hierarchical clustering and classification/regression trees, such that all of these can use the same engine for plotting or cutting trees.

A dendrogram object represents a tree as a list object, with various attributes.

For example, let's create a dendrogram object based on an heirarchical clustering of 4 states in the U.S.:

```{r}
# our data:
data(USArrests)
US_data <- USArrests[c(2,5,32,35),]
print(US_data)

hc <- hclust(dist(US_data), "ave") # create an heirarchical clustering object
dend <- as.dendrogram(hc)

```

Dendrogram has several useful methods bundled with R:

```{r}
methods(class="dendrogram")
```

Here are some examples for their use:

```{r}
print(dend)
labels(dend)
str(dend)
str(dend[[2]]) # looking at one branch of the dendrogram
plot(dend)
```

You might notice how the order of the items (leaves/terminal nodes) of the dendrogram is different than their order in the table. In order to re-order the rows in the data-table to have the same order as the items in the dendrogram, we can use the *order.dendrogram* function:

```{r}
(new_order <- order.dendrogram(dend)) # the order of the original items to have them be at the same order as they assume in the dendrogram
print(US_data[new_order,])
```




In order to see what our dendrogram (list) object includes, we need to use the **unclass** function, which will allow us to print the list as is, without going through the print.dendrorgam method:

```{r}
unclass(dend)
```

We can see how each node in the dendrogram/list object has the following (self explaining) attributes:
```{r}
names(attributes(dend)[-4])
```
Also, terminal nodes also has the "leaf" attribute (set to TRUE).


### Motivation for creating {**_dendextend_**}

The *dendrogram* object has several **advantages**:

1. *dendrogram* objects are simply list R objects. This makes their structure  very simple to understand by R users.
2. *dendrogram* objects has various methods and functions for using them in R. 
3. *dendrogram* objects are relatively simple to manipulte and extend.
4. Other tree objects (such as *hclust*, and objects from the *{ape}* package) include an *as.dendrogram* method for converting their objects into a dendrogram.

However, even with all of its advantages, the *dendrogram* class in R still lacks various basic features.

The {**_dendextend_**} package aims at filling some gaps in base R, by extending the available functions for dendrogram manipulation, statistical analysis, and visualization.

This vignettes Provides a step-by-step description of the functionality provided by the {**_dendextend_**} package.


### Installing {**_dendextend_**}

To install the stable version from CRAN use:

```{r eval=FALSE}
install.packages('dendextend') # not yet available from CRAN
```

To install the [GitHub version](https://github.com/talgalili/dendextend) use:

```{r eval=FALSE}
if (!require('devtools')) install.packages('devtools'); require('devtools')
install_github('dendextend', 'talgalili')
```


Labels extraction and assignment 
--------------------------------

### labels in base R

In base R, the *labels* function is intended to find/extract a suitable set of labels from an object for use in printing or plotting, for example. By default, it uses the *names* and *dimnames* functions.

What base R *labels* function is mising is assignment. In the next few examples we will go through different examples of what the {**_dendextend_**} package offers for various objects.

**Credit:** These assignment functions were originally written by Gavin Simpson (in a post on [stackoverflow](http://stackoverflow.com/questions/4614223/how-to-have-the-following-work-labelsx-some-value-r-question)), and adopted/adjusted to this package by Tal Galili.


### labels for vectors and matrixes

In base R, for vectors, labels gives the *names* of the object. And if these are missing, then *labels* will give the vector itself as a character vector:

```{r}
x <- 1:3 
names(x) # this vector has no names
labels(x) # this vector has no labels
```

Assignment to names is available in base R and works as follows:

```{r}
x <- 1:3 
names(x) <- letters[1:3] # assignment for names is in base R
#both names and labels will give the same result:
names(x) 
labels(x)
```


The new labels assignment function will allow a user to change the labels of the vector just as if it was "names":

```{r}
   x <- 1:3 
   labels(x) <- letters[1:3]
   names(x) 
   labels(x)
```

Labels assignment are also available for matrixes.



### labels for dendrogram objects


### labels for hclust objects








