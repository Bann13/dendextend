---
output:
  html_document:
    self_contained: no
    toc: true    
---
<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Introduction to dendextend}
-->

```{r, echo = FALSE, message = FALSE}
library(dendextend)
library(knitr)
knitr::opts_chunk$set(
  comment = "#>",
  error = FALSE,
  tidy = FALSE,
  fig_path = "figure-intro\\")
```

Introduction to dendextend
===========================

**Author**: [Tal Galili](http://www.r-statistics.com/) ( Tal.Galili@gmail.com )

**tl;dr**: the [_dendextend package_](http://cran.r-project.org/web/packages/dendextend/) let's you create figures like this:


```{r, echo=FALSE, warning=FALSE, fig.align='center'}
suppressMessages(library(dendextend))
suppressMessages(library(dendextendRcpp))
library(colorspace)

dend1 <- c(1:5) %>% # take some data
         dist %>% # calculate a distance matrix, 
         hclust(method = "average") %>% # on it compute hierarchical clustering using the "average" method, 
         as.dendrogram # and lastly, turn that object into a dendrogram.
dend2 <- c(1:5) %>% # take some data
         dist %>% # calculate a distance matrix, 
         hclust(method = "single") %>% # on it compute hierarchical clustering using the "average" method, 
         as.dendrogram # and lastly, turn that object into a dendrogram.
dend1 <- rotate(dend1, order = c(as.character(5:1)))
labels(dend1) <- rev(c("dendextend", "let's u easily", "control","(and compare) your", "dendrograms"))
labels(dend2) <- rev(c("let's u easily","dendextend" ,"control","(and compare) your", "dendrograms"))
dend1 <- dend1 %>% 
         color_labels %>% 
         set("labels_cex", c(2.2,1.4)) %>% 
         set("branches_lwd", c(4,1,4)) %>% 
         set("branches_lty", c(1,2,1)) %>% 
         set("nodes_pch", c(NA,19,NA)) %>% 
         set("nodes_cex", c(NA,2.5,NA)) %>% 
         set("nodes_col", c(NA,3,NA)) %>% 
         hang.dendrogram # %>% plot
dend2 <- color_branches(dend2)
# dend2 <- color_labels(dend2)
tanglegram(dendlist(dend1, dend2), margin_inner = 9, 
           color_lines = c(rep("darkgreen", 3) , rep("darkred",2)),
           sub= paste("Entanglement:", round(entanglement(dendlist(dend1, dend2)),2)), cex_sub = 1.5
           )

# dend2 %>% color_branches %>% plot
# dend2 %>% color_branches(k=3) %>% plot # nice, returns the tree as is...
# dend2 %>% color_labels %>% plot
# cutree(dend2,3)


```




Introduction
--------------


When visualizing a hierarchical clustering as a tree (also known as a *dendrogram*), we are often interested in **adjusting its graphical paramters**: the color, size, type, etc of the branches, nodes and labels. Also, when considering several models - we would like to visually and statistically **compare different dendrograms** to one another.

The [**_dendextend package_**](http://cran.r-project.org/web/packages/dendextend/) offers a set of functions for making these tasks both possible and simple to do.

The goal of this document is to introduce you to the basic functions that dendextend provides, and show how they may be applied. As a toy example, we will analyse the (overly) famous Iris dataset, while making extensive use of "chaining" (both are explained next).


Prerequisites
--------------

### Acknowledgement

This package was made possible by the the support of my thesis advisot [Yoav Benjamini](http://www.math.tau.ac.il/~ybenja/), as well as code contributions from many R users. They are:

```{r, echo=FALSE}

c(person("Tal", "Galili", role = c("aut", "cre", "cph"), email =
    "tal.galili@gmail.com", comment = "http://www.r-statistics.com"),
    person("Gavin", "Simpson", role = "ctb"), person("Gregory","Jefferis", role
    = "ctb", email = "jefferis@gmail.com",
    comment ="imported code from his dendroextras package"),
    person("Marco", "Gallotta", role = "ctb", comment =
    "a.k.a: marcog") , person("Johan", "Renaudie", role = "ctb", comment =
    "https://github.com/plannapus"), person("R core team", role = "ctb",
    comment = "Thanks for the Infastructure, and code in the examples"),
    person("Kurt", "Hornik", role = "ctb"), person("Uwe", "Ligges",
    role = "ctb"), person("Andrej-Nikolai", "Spiess", role = "ctb"),
    person("Steve", "Horvath",email = "SHorvath@mednet.ucla.edu", role =
    "ctb"), person("Peter", "Langfelder",email = "Peter.Langfelder@gmail.com",
    role = "ctb"), person("skullkey", role = "ctb"), person("Mark",
    "Van Der Loo", email = "mark.vanderloo@gmail.com", comment =
    "https://github.com/markvanderloo d3dendrogram", role = "ctb"),
    person("Yoav", "Benjamini", role = "ths"))

```


The **design** of the dendextend package (and this manual!) is heavily inspired by [Hadley Wickham's](http://had.co.nz/) work. Especially his text on [writing an R package](http://adv-r.had.co.nz/Package-basics.html), the [devtools package](http://cran.r-project.org/web/packages/devtools/), and the dplyr package (specifically the use of chaining, and the [Introduction text to dplyr](http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html)).




### Chaining

Function calls in dendextend often get a dendrogram and returns a (modified) dendrogram. This doesn't lead to particularly elegant code if you want to do many operations at once. The same is true even in the first stage of creating a dendrogram.

In order to construct a dendrogram, you will (often) need to go through several steps. You can either do so while keeping the intermediate results:

```{r, eval = FALSE}
d1 <- c(1:5) # some data
d2 <- dist(d1)
d3 <- hclust(d2, method = "average")
dend <- as.dendrogram(d3)
```

Or, you can also wrap the function calls inside each other:

```{r, eval=FALSE}
dend <- as.dendrogram(hclust(dist(c(1:5)), method = "average"))
```

However, both solutions are not ideal: the first solution includes redundent intermediate objects, while the second is difficult to read (since the order of the operations is from inside to out, while the arguments are a long way away from the function).

To get around this problem, dendextend encourages the use of the `%>%` ("pipe" or "chaining") operator (imported from the magrittr package). This turns `x %>% f(y)` into `f(x, y)` so you can use it to rewrite ("chain") multiple operations such that they can be read from left-to-right, top-to-bottom. 

For example, the following will be written as it would be explained: 

```{r, eval = FALSE}
dend <- c(1:5) %>% # take the iris dataset, 
         dist %>% # calculate a distance matrix, 
         hclust(method = "average") %>% # on it compute hierarchical clustering using the "average" method, 
         as.dendrogram # and lastly, turn that object into a dendrogram.
```

For more details, you may look at:

* [magrittr on CRAN](http://cran.r-project.org/web/packages/magrittr/)
* [Introduction to the magrittr package](http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html)
* [Simpler R coding with pipes > the present and future of the magrittr package](http://www.r-statistics.com/2014/08/simpler-r-coding-with-pipes-the-present-and-future-of-the-magrittr-package/)




How to set a dendrogram's parameters
------------------------------------

The fastest way to start changing a dendextend's parameters is by using the `set` function. It is written as: `set(object, what, value)`, and accepts the following parameters:

1. **object**: a dendrogram object, 
2. **what**: a character indicating what is the property of the tree that should be set/updated
3. **value**: a vector with the value to set in the tree. (the type of the value depends on the "what")

The **what** parameter accepts many options, each uses some general function in the background. These options deal with labels, nodes and branches. They are:

* labels - set the labels (using `labels<-.dendrogram`)
* labels_colors - set the labels' colors (using `color_labels`)
* labels_cex - set the labels' size (using `assign_values_to_leaves_nodePar`)
* leaves_pch - set the leaves' point type (using `assign_values_to_leaves_nodePar`)
* leaves_cex - set the leaves' point size (using `assign_values_to_leaves_nodePar`)
* leaves_col - set the leaves' point color (using `assign_values_to_leaves_nodePar`)
* nodes_pch - set the nodes' point type (using `assign_values_to_nodes_nodePar`)
* nodes_cex - set the nodes' point size (using `assign_values_to_nodes_nodePar`)
* nodes_col - set the nodes' point color (using `assign_values_to_nodes_nodePar`)
* hang_leaves - hang the leaves (using `hang.dendrogram`)
* branches_k_color - color the branches (using `color_branches`)
* branches_col - set the color of branches (using `assign_values_to_branches_edgePar`)
* branches_lwd - set the line width of branches (using `assign_values_to_branches_edgePar`)
* branches_lty - set the line type of branches (using `assign_values_to_branches_edgePar`)
* by_labels_branches_col - set the color of branches with specific labels (using `branches_attr_by_labels`)
* by_labels_branches_lwd - set the line width of branches with specific labels (using `branches_attr_by_labels`)
* by_labels_branches_lty - set the line type of branches with specific labels (using `branches_attr_by_labels`)
* clear_branches - clear branches' attributes (using `remove_branches_edgePar`)
* clear_leaves - clear leaves' attributes (using `remove_branches_edgePar`)

For illustration purposes, We'll create a small tree with 5 leaves, and demonstrate these functions with it.

```{r, fig.show='hold', fig.width=4, fig.height=3}
dend <- c(1:5) %>% # take some data
         dist %>% # calculate a distance matrix, 
         hclust(method = "average") %>% # on it compute hierarchical clustering using the "average" method, 
         as.dendrogram # and lastly, turn that object into a dendrogram.

dend %>% plot
# we could have also used plot(dend)
```


### Changing a dendrogram's labels

We notice that the tree's labels are not 1 to 5 by order, since the tree happened to place them in a different order:

```{r}
# get the labels:
dend %>% labels
# this is just like labels(dend)
```

We can change the names of the labels:

```{r, fig.width=8, fig.height=3}
# change the labels, and then print them:
dend %>% set("labels", c(111:115)) %>% labels
# could also be done using:
# labels(dend) <- c(111:115)
```

We may also chance their color and size. Notice how the function recycles the vector of values we give it, from left to right:

```{r, fig.width=8, fig.height=3}
par(mfrow = c(1,2))
dend %>% plot(main = "Before")
dend %>% 
   set("labels", c(111:115)) %>%    # change labels
   set("labels_col", c(1,2,3)) %>%  # change color 
   set("labels_cex", c(2,1)) %>%    # change size
   plot(main = "After")
```


When it comes to color, we can also set the parameter "k", which will cut the tree into k clusters, and assign a different color to each label (based on its cluster):

```{r, fig.width=8, fig.height=3}
par(mfrow = c(1,2))
dend %>% set("labels_cex", 2) %>% set("labels_col", value = c(3,4))        %>% plot(main = "Recycles color \nfrom left to right")
dend %>% set("labels_cex", 2) %>% set("labels_col", value = c(3,4), k=2)   %>% plot(main = "Color labels \nper cluster")
abline(h = 2, lty = 2)
```


### Changing a dendrogram's nodes/leaves (points)

### Changing a dendrogram's branches



### Exploring a dendrogram's parameters

While setting parameters, we would also like to be able to check the current parameters in a dendrogram. Here are several functions for doing it for the following tree:

```{r}
dend <- c(1:5) %>% # take the iris dataset, 
         dist %>% # calculate a distance matrix, 
         hclust(method = "average") %>% # on it compute hierarchical clustering using the "average" method, 
         as.dendrogram # and lastly, turn that object into a dendrogram.

dend2 <-
   dend %>% 
      assign_values_to_nodes_nodePar(19, "pch") %>% 
      assign_values_to_nodes_nodePar(2, "col") %>% 
      assign_values_to_nodes_nodePar(2, "cex") %>% 
      assign_values_to_leaves_nodePar(3, "col") %>% 
   plot

dend %>% plot
```


```{r}
dend %>% labels # get the labels of the tree
dend %>% nleaves # get the number of leaves of the tree
dend %>% nnodes # get the number of nodes in the tree (including leaves)
dend %>% plot
dend %>% plot



```





Changing a dendrogram's structure
----------------------------------

### Rotation

### Pruning


Comparing two dendrograms
--------------------------

### tanglegram


### Correlation measures


### Bk plots





Enhancing other packages
--------------------------

### qplots

`heatmap.2`

### pvclust

### dynamicCutree

`colored_bars`


dendextendRcpp - on the need for speed
----------------------------------------------


TODO: mention: https://en.wikipedia.org/wiki/Depth-first_search






### The Iris dataset

> The famous (Fisher's or Anderson's) iris data set gives the measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica. (from `?iris`)



The [Iris flower data set](https://en.wikipedia.org/wiki/Iris_flower_data_set) is fun for learning supervised classification algorithms, and is known as a difficult case for unsupervised learning. This is easily seen through the following Scatter PLot Matrix:

```{r, fig.width=9, fig.height=9, fig.show='hold'}
data(iris)

species_labels <- iris[,5]
library(colorspace) # get nice colors
species_col <- rev(rainbow_hcl(3))[as.numeric(species_labels)]

# Plot a SPLOM:
pairs(iris[,-5], col = species_col,
      lower.panel = NULL,
       cex.labels=2, pch=19, cex = 1.2)

# Add a legend
par(xpd = TRUE)
legend(x = 0.05, y = 0.4, cex = 2,
   legend = as.character(levels(species_labels)),
   	fill = unique(species_col))
par(xpd = NA)

```

We can see that the *Setosa* species are distincly different than *Versicolor* and *Virginica* (they have lower pater length and width). But *Versicolor* and *Virginica* can not easily be seperated based on measurments of their Sepal and Patal width/length.
