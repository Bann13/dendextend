---
title: "Hierarchical cluster analysis on famous datasets - enhanced with the _dendextend_ package)"
author: "Tal Galili"
output: 
  html_document: 
    toc: yes
---


```{r, echo = FALSE, message = FALSE, warning=FALSE}
library(dendextend)
library(knitr)
knitr::opts_chunk$set(
   cache = TRUE,
   dpi = 200,
  comment = "#>",
  tidy = FALSE)

# http://stackoverflow.com/questions/24091735/why-pandoc-does-not-retrieve-the-image-file
# < ! -- rmarkdown v1 -->

```


## Introduction

This document demonstrats, on several famous datasets, how the _dendextend_ R package can be used to enhance Hierarchical Cluster Analysis (through better visualization and sensitivity analysis). 



## The Iris dataset

### background

> The famous (Fisher's or Anderson's) iris data set gives the measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica. (from `?iris`)



The [Iris flower data set](https://en.wikipedia.org/wiki/Iris_flower_data_set) is fun for learning supervised classification algorithms, and is known as a difficult case for unsupervised learning. This is easily seen through the following Scatter PLot Matrix (SPLOM):

Define variables:

```{r}
iris <- datasets::iris
iris2 <- iris[,-5]
species_labels <- iris[,5]
library(colorspace) # get nice colors
species_col <- rev(rainbow_hcl(3))[as.numeric(species_labels)]
```

SPLOM:

```{r, fig.width=9, fig.height=9, fig.show='hold'}
# Plot a SPLOM:
pairs(iris2, col = species_col,
      lower.panel = NULL,
       cex.labels=2, pch=19, cex = 1.2)

# Add a legend
par(xpd = TRUE)
legend(x = 0.05, y = 0.4, cex = 2,
   legend = as.character(levels(species_labels)),
   	fill = unique(species_col))
par(xpd = NA)

```

We can see that the *Setosa* species are distinctly different than *Versicolor* and *Virginica* (they have lower petal length and width). But *Versicolor* and *Virginica* can not easily be separated based on measurements of their Sepal and Patel width/length.

The same conclusion can be made by looking at the parallel coordinates plot of the data:

```{r, fig.height=3}
# http://blog.safaribooksonline.com/2014/03/31/mastering-parallel-coordinate-charts-r/
library(MASS)
par(las = 1, mar = c(4.5, 3, 3, 2) + 0.1, cex = .8)
parcoord(iris2, col = species_col, var.label = TRUE, lwd = 2)

# Add Title
title("Parallel coordinates plot of the Iris data")
# Add a legend
par(xpd = TRUE)
legend(x = 1.75, y = -.25, cex = 1,
   legend = as.character(levels(species_labels)),
   	fill = unique(species_col), horiz = TRUE)
par(xpd = NA)

```


### The 3 clusters from the "complete" method vs the real species category


The default hierarchical clustering method in `hclust` is "complete". We can visualize the result of running it by turning the object to a dendrogram and making several adjustments to the object, such as: changing the labels, coloring the labels based on the real species category, and color the branches based on cutting the tree to 3 produce clusters.

```{r, fig.height = 10, fig.width=7}

d_iris <- dist(iris2) # method="man" # is a bit better
hc_iris <- hclust(d_iris, method = "complete")
iris_species <- rev(levels(iris[,5]))

library(dendextend)
dend <- as.dendrogram(hc_iris)
# order it the closest we can to the order of the observations:
dend <- rotate(dend, 1:150)

# Color the branches based on the clusters:
dend <- color_branches(dend, k=3) #, groupLabels=iris_species)

# manually match the labels, as much as possible, to the real classification of the flowers:
labels_colors(dend) <-
   rainbow_hcl(3)[sort_levels_values(
      as.numeric(iris[,5])[order.dendrogram(dend)]
   )]

# We'll add the flower type to the labels:
labels(dend) <- paste(as.character(iris[,5])[order.dendrogram(dend)],
                           "(",labels(dend),")", 
                           sep = "")
# we hang the dendrogram a bit:
dend <- hang.dendrogram(dend,hang_height=0.1)
# reduce the size of the labels:
# dend <- assign_values_to_leaves_nodePar(dend, 0.5, "lab.cex")
dend <- set(dend, "labels_cex", 0.5)
# And plot:
par(mar = c(3,3,3,7))
plot(dend, 
     main = "Clustered Iris dataset
     (the labels give the true flower species)", 
     horiz =  TRUE,  nodePar = list(cex = .007))
legend("topleft", legend = iris_species, fill = rainbow_hcl(3))

#### BTW, notice that:
# labels(hc_iris) # no labels, because "iris" has no row names
# is.integer(labels(dend)) # this could cause problems...
# is.character(labels(dend)) # labels are no longer "integer"
```


This visualization easily demonstrates how the separation of the Hierarchical clustering is very good with the "Setosa" species, but misses in labeling many "Versicolor" species as "Virginica".

The hanging of the tree also helps to locate extreme observations. For example, we can see that observation "virginica (107)" is not very similar to the Versicolor species, but still, it is among them. Also, "Versicolor (71)" is too much "within" the Virginica bush, and it is a wonder why that is.  

```{r, echo=FALSE, eval=FALSE}
# some_col_func <- function(n, top_color = "red4") {
#   seq_cols <- c("#F7FCFD", "#E0ECF4", "#BFD3E6", "#9EBCDA", "#8C96C6", "#8C6BB1", 
#                 "#88419D", "#810F7C")
#   c(colorRampPalette(seq_cols, bias =1)(n-1), top_color)
# } 

```

We can also explore the data using a heatmap. The rows are ordered based on the order of the hierarchical clustering (using the "complete" method). The colored bar indicates the species category each row belongs to. The color in the heatmap indicates the length of each measurment (from light yelow to dark red).

In the heatmap we also see how the Setosa species has low Petal values (in light yelow), but it is very difficult to see any clear distinction in between the other two species.


```{r}

some_col_func <- function(n) rev(colorspace::heat_hcl(n, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.5)))

# scaled_iris2 <- iris2 %>% as.matrix %>% scale
library(gplots)
heatmap.2(as.matrix(iris2), 
          main = "Heatmap for the Iris dataset",
          srtCol = 20,
          dendrogram = "row",
          Rowv = dend,
          Colv = "NA", # this to make sure the columns are not ordered
          trace="none",          
          margins =c(5,0.1),      
          key.xlab = "Cm",
          denscol = "grey",
          density.info = "density",
          RowSideColors = rev(labels_colors(dend)), # to add nice colored strips		
          col = some_col_func
         )


```


### Similarity/difference between various clustering algorithems


We may ask ourselves how much different results we could get if we would use different clustering algorithms  would different clustering algorithms (`hclust` has 8 different algorithms implemented). For the purpose of this analysis we will create all 8 hclust objects, and chain them together into a single `dendlist` object (which, as the name implies, can hold a bunch of dendrograms together for the purpose of further analysis).

```{r}

hclust_methods <- c("ward.D", "single", "complete", "average", "mcquitty", 
        "median", "centroid", "ward.D2")
iris_dendlist <- dendlist()
for(i in seq_along(hclust_methods)) {
   hc_iris <- hclust(d_iris, method = hclust_methods[i])   
   iris_dendlist <- dendlist(iris_dendlist, as.dendrogram(hc_iris))
}
names(iris_dendlist) <- hclust_methods
iris_dendlist
```

Next, we can look at the cophenetic correlation between each clustering result using `cor.dendlist` (this can be nicely plotted using the `corrplot` function from the _corrplot_ package):

```{r, fig.width=8, fig.height=8}
iris_dendlist_cor <- cor.dendlist(iris_dendlist)
iris_dendlist_cor
corrplot::corrplot(iris_dendlist_cor, "pie", "lower")
```

From the above figure we can easily see that most clustering methods yield very similar results, except for the complete method (the default method in `hclust`), which yields a correlation measure of around 0.6. 

To further explore the similarity and difference between the alternative clustering algorithms, we can turn to using the `tanglegram` function (which works for either two `dendrogram`s, or a `dendlist`). 

First, let's see two methods which are very similar: ward.D vs ward.D2. From a first glance we can see how they both give the same result for the top 3 clusters. However, since they are both ladderizes (i.e.: having their smaller branch rotated to be higher for each node), we can see that their clustering is not identical (due to the crossings).

```{r, fig.height=5}
# the which parameter allows us to pick the elements in the list to compare
iris_dendlist %>% dendlist(which = c(1,8)) %>% ladderize %>% 
   set("branches_k_color", k=3) %>% 
   # untangle(method = "step1side", k_seq = 3:20) %>%
   # set("clear_branches") %>% #otherwise the single lines are not black, since they retain the previous color from the branches_k_color.
   tanglegram(faster = TRUE) # (common_subtrees_color_branches = TRUE)
```


Next, let's look at two methods which also have a high cophenetic correlation: ward.D vs the average:

```{r, fig.height=5}
# the which parameter allows us to pick the elements in the list to compare
iris_dendlist %>% dendlist(which = c(1,4)) %>% ladderize %>% 
   set("branches_k_color", k=2) %>% 
   # untangle(method = "step1side", k_seq = 3:20) %>%
   tanglegram(faster = TRUE) # (common_subtrees_color_branches = TRUE)
```

We see that when it comes to the major clusters, the two algorithms perform quite similarly.

However, how are they doing inside each of the clusters? It is quite difficult to compare the two because of the high value in ward.D. For comparison purposes, we can "rank" the heights of the branches in the two dendrogram (while still preserving their internal order). Next, we can highlight the shared common sub-trees (With different colors), and the distinct edges (with a dashed line):

```{r, fig.height=5}
# the which parameter allows us to pick the elements in the list to compare
iris_dendlist %>% dendlist(which = c(1,4)) %>% ladderize %>% 
   # untangle(method = "step1side", k_seq = 3:20) %>%
   set("rank_branches") %>%
   tanglegram(common_subtrees_color_branches = TRUE)
```

We have 39 subtrees which are identical between the two dendrograms:

```{r}
length(unique(common_subtrees_clusters(iris_dendlist[[1]], iris_dendlist[[4]]))[-1])
# -1 at the end is because we are ignoring the "0" subtree, which indicates leaves that are singletons.
```

What we can learn from this is that actually the two algorithms seem to give quite different results in the high resolution (higher cuts). However, since both capture the two major clusters (Setosa vs the others), they are considered quite similar by the cophenetic correlation.

But what about the "complete" method (which got a lower cophenetic correlation with the other methods)? When we compare complete vs average, we can quickly see that "complete" the splitting of the clusters is much more balanced, and mixes the "Setosa" species with another one. This is probably the cause for the big difference found in the cophenetic correlation between the "complete method" and the other clustering methods:

```{r, fig.height=5}
# the which parameter allows us to pick the elements in the list to compare
iris_dendlist %>% dendlist(which = c(3,4)) %>% ladderize %>% 
   untangle(method = "step1side", k_seq = 2:6) %>%
   set("branches_k_color", k=2) %>% 
   tanglegram(faster = TRUE) # (common_subtrees_color_branches = TRUE)
```


We can quickly plot all 8 methods to see this phenomenon (i.e.: that complete has its smaller cluster larger than it is in all the other clustering methods):

```{r, fig.height=15}
par(mfrow = c(4,2))
for(i in 1:8) {
   iris_dendlist[[i]] %>% set("branches_k_color", k=2) %>% plot(axes = FALSE, horiz = TRUE)
   title(names(iris_dendlist)[i])
}
```

It seems that the cophenetic correlation is very biased towards the influance of the main clusters. Another correlation measure to use is the `cor_common_nodes` correlation (giving the proportion of nodes which share the exact same list of labels in both dendrograms). We can also check it out:

```{r, fig.width=8, fig.height=8}
iris_dendlist_cor2 <- cor.dendlist(iris_dendlist, method = "common")
iris_dendlist_cor2
corrplot::corrplot(iris_dendlist_cor2, "pie", "lower")
```

This gives us an another perspective on our clustering algorithms. We can see that most methods have around 75% common nodes with one another. centroid and median seem relatively close to one another, as well as ward.D2 and ward.D to one another and to complete, average, and mcquitty (as compared to the other methods).


### Clustering prediction of the 3 species classes

Lastly, we would like to see which of the different clustering algorithms came the closest to detecting the 3 flower species (when using a cut of k=3).

For this purpose we compare the clustering solution of each algorithm with the real clusters, using the Fowlkes-Mallows Index (also using in the package for the `Bk_plot`). This measure is similar to rand (or rand adjusted) index, and gives a value of 1 when the two clusters confirm, and 0 when they do not.

```{r}

get_ordered_3_clusters <- function(dend) {
   cutree(dend, k = 3)[order.dendrogram(dend)]
}

dend_3_clusters <- lapply(iris_dendlist, get_ordered_3_clusters)

compare_clusters_to_iris <- function(clus) {FM_index(clus, rep(1:3, each = 50), assume_sorted_vectors = TRUE)}

clusters_performance <- sapply(dend_3_clusters, compare_clusters_to_iris)
dotchart(sort(clusters_performance), xlim = c(0.7,1),
         xlab = "Fowlkes-Mallows Index (from 0 to 1)",
         main = "Perormance of clustering algorithms \n in detecting the 3 species",
         pch = 19)
```

We can see that the "median" method did the best, although similar results were achieved by ward.D2, average, ward.D, and mcquitty. However, the complete, centroid, and single method did quite worse in our case.




### Conclusion

The Iris dataset is only 4-dimensional, making it possible to explore using pairs plot (SPLOM) or parallel coordinates plot. It is clear from these that two main clusters are visible, while the seperation of the third cluster is difficult.

In the above analysis we learned that the complete method fails to do the proper seperation of the two main clusters when cut in k=2 (but succeds in doing it, if moving to k=3 clusters). This is different than all the other 7 methods available in `hclust`, which do succeed in seperating the 2 main clusters from the beginning (i.e.: for k=2).

We also noticed that all clustering algorithms share a relatively high proportion of common nodes (between 75% to 90%).

Lastely, when it came to seperating the flowers to the 3 species, the median clustering method did the best, while the single method did the worst in this regards. 

While the Iris dataset is well known, I hope the above analysis was able to offer some new perspectives on the performance of the different hierarchical clustering methods.







